import numpy as np
import random
import nltk
from nltk.corpus import wordnet
from nltk.tokenize import word_tokenize
from nltk.tag import pos_tag
from collections import Counter
from typing import List, Tuple, Union, Dict, Any
import yaml
from .base import BaseGenerator


class WordFlippingGenerator(BaseGenerator):
    """
    Randomly flips words with defined POS tags to their antonyms
    """

    # This uses the following algorithm
    # Note: the word "flip" will be used to define the operation of getting an antonym of a specific word
    #     1. User should define the POS tags relevant to the words that must be flipped.
    #     2. The user should invoke the functionality by specifying an original sentence and the number of variations they want
    #     3. The algorithm will tokenize the words
    #     4. The algorithm will generate a mask list corresponding to these tokens by refering to the POS tags previously defined by the user.
    #         A truth value in this mask will represent that the word must be flipped and false will mean otherwise
    #     5. The algorithm will generate a set of lists of antonyms for the words to be flipped by refering to the mask above
    #         These lists will have words ordered in the descending order of the probabilities of their occurence
    #     6. New sentences will be generated by merging the original words and antonyms appropriately
    # Throughout the implementation, following conventions will be used
    #   1. Number of variations defined by the user: n
    #   2. Number of flipping words in a given phrase: m

    def __init__(self, config: str) -> None:
        # read the config file
        if type(config) == str:
            with open(config) as handler:
                config = yaml.load(handler, yaml.FullLoader)
        sample_prob_decay_factor = config["sample_prob_decay_factor"]
        flip_prob = config["flip_prob"]
        flipping_tags = config["flipping_tags"]
        name = config["name"]

        # validate the values
        if (flip_prob < 0) or (flip_prob > 1):
            raise ValueError("'flip_prob' should be in range [0,1]")
        if sample_prob_decay_factor < 0:
            raise ValueError("'sample_prob_decay_factor' must be a positive value")
        if len(flipping_tags) == 0:
            raise ValueError("'flipping_tags' array should be longer than 0")

        self.name = name
        self.flip_prob = flip_prob
        self.sample_prob_decay_factor = sample_prob_decay_factor
        self.flipping_tags = flipping_tags

    def _get_antonyms(self, word: str) -> List[str]:
        """
        Returns a set of antonyms of a given word.
        These words are ordered in the dscending order of the probability of their occurence
        """
        antonym_count = Counter()

        synsets = wordnet.synsets(word)
        for syn in synsets:
            for lemma in syn.lemmas():
                if lemma.antonyms():
                    for ant in lemma.antonyms():
                        antonym_count[ant.name()] += 1

        sorted_antonyms = [ant for ant, _ in antonym_count.most_common()]
        sorted_antonyms = [ant.replace("_", " ") for ant in sorted_antonyms]  # "is_not"
        return sorted_antonyms

    def _get_flip_mask(self, tag: str) -> bool:
        """
        Refers to a lookup table of tags and returns if the current tag corresponds to a
        flipping word or not
        """
        can_flip = tag in self.flipping_tags
        return can_flip

    def _sample_list(self, word_list: List[str], m: int) -> List[str]:
        """
        Samples words from the given word list randomly m times and returns them
        This sampling is done by refering to a exponentially decaying distribution
        Arguments:
            1. word_list: List[str]: The word list in the decreasing probabilistic order
            2. m: int: The number of times the sampling must be done
        Returns
            1. m number of sampled words
        """
        num_words = len(word_list)
        probabilities = [
            np.exp(-self.sample_prob_decay_factor * i) for i in range(num_words)
        ]
        total_prob = sum(probabilities)
        normalized_probs = [p / total_prob for p in probabilities]

        sampled_indices = [
            np.random.choice(num_words, p=normalized_probs) for i in range(m)
        ]
        sampled_words = [word_list[idx] for idx in sampled_indices]
        return sampled_words

    def _find_nth_true_index(self, boolean_list: List[bool], n: int) -> int:
        """
        Finds the position of the nth truth in a given boolean array
        """
        count = 0
        for index, value in enumerate(boolean_list):
            if value:
                count += 1
                if count == n:
                    return index
        return -1

    def _clean_masks(
        self, masks: List[bool], flipped_words: [List[List[str]]]
    ) -> Tuple[Union[bool, List[List[str]]]]:
        """
        Cleans the mask list
        When a set of antonyms are given, empty antonym lists might be observed
        In such cases, the relevant word will not be flipped.
        This method will remove such empty lists and then update the mask list.
        """
        new_masks = masks.copy()
        new_flipped_words = []
        for i, words in enumerate(flipped_words):
            if len(words) > 0:
                new_flipped_words.append(words)
            else:
                mask_i = self._find_nth_true_index(masks, i + 1)
                new_masks[mask_i] = False
        return (new_masks, new_flipped_words)

    def _merge_words(
        self,
        originals: List[str],
        opposites: List[List[str]],  # has the shape (m, z), z âˆˆ {non-negative integers}
        masks: List[bool],
        variations: int,  # n
    ) -> List[str]:
        """
        Merges original words and antonyms appropriately to create sentences
        """
        opposites = [
            self._sample_list(single_list, variations) for single_list in opposites
        ]  # has the shape (m, n)
        weights = (self.flip_prob, 1 - self.flip_prob)
        new_sentences = []

        # iterate parallely over all the opposite word lists
        for opposite in zip(*opposites):
            opposite = list(opposite)
            new_sent = []
            for i, mask in enumerate(masks):
                if mask:
                    word = opposite.pop(0)
                    word = random.choices((word, originals[i]), weights=weights, k=1)[0]
                else:
                    word = originals[i]
                new_sent.append(word)
            new_sent = " ".join(new_sent)
            new_sentences.append(new_sent)
        return new_sentences

    def __call__(self, inp: str, variations: int = 4) -> List[str]:
        words = word_tokenize(inp)
        word_tags = pos_tag(words)
        masks = [self._get_flip_mask(tag) for (word, tag) in word_tags]
        flipping_words = [word for (word, mask) in zip(words, masks) if mask]
        flipped_words = [self._get_antonyms(word) for word in flipping_words]
        masks, flipped_words = self._clean_masks(masks, flipped_words)
        opposite_sentences = self._merge_words(words, flipped_words, masks, variations)

        return opposite_sentences

    def describe_tags(self) -> None:
        nltk.help.upenn_tagset()

    def set_tags(self, flipping_tags: List[str]) -> None:
        if len(flipping_tags) == 0:
            raise ValueError("'flipping_tags' array should be longer than 0")
        self.flipping_tags = flipping_tags

    def set_flipping_prob(self, flip_prob: float) -> None:
        if (flip_prob < 0) or (flip_prob > 1):
            raise ValueError("'flip_prob' should be in range [0,1]")
        self.flip_prob = flip_prob

    def set_sample_prob_decay_factor(self, sample_prob_decay_factor: float) -> None:
        if sample_prob_decay_factor < 0:
            raise ValueError("'sample_prob_decay_factor' must be a positive value")
        self.sample_prob_decay_factor = sample_prob_decay_factor

    def set_config(self, config: Dict[str, Any]) -> None:
        required_keys = ["sample_prob_decay_factor", "flip_prob", "flipping_tags"]
        if any([val not in config.keys() for val in required_keys]):
            raise ValueError(
                f"Invalid configuration file. The keys {required_keys} are required in the configuration."
            )
        sample_prob_decay_factor = config["sample_prob_decay_factor"]
        flip_prob = config["flip_prob"]
        flipping_tags = config["flipping_tags"]

        # validate the values
        if (flip_prob < 0) or (flip_prob > 1):
            raise ValueError("'flip_prob' should be in range [0,1]")
        if sample_prob_decay_factor < 0:
            raise ValueError("'sample_prob_decay_factor' must be a positive value")
        if len(flipping_tags) == 0:
            raise ValueError("'flipping_tags' array should be longer than 0")

        self.flip_prob = flip_prob
        self.sample_prob_decay_factor = sample_prob_decay_factor
        self.flipping_tags = flipping_tags
